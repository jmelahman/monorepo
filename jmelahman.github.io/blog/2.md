---
title-prefix: "Blog"
date: 2025-08-12
nav_blog: true
---

# Using `uv` to package Go applications

I love Go and I love [`uv`](https://docs.astral.sh/uv/).

Combining the two may seem unlikely at a glance given the limited interop between Python and Go.
Moreover, the Go ecosystem is rich with top-tier developer tools (a domain in which Go itself excels).
To make matters worse, Go and Python have relatively divergent core beliefs as languages.

In short, Python has core standards it upholds while allowing downstream developers complete
freedom to create software they need within those boundaries.
In contrast, Go's core beliefs value simplicity and which allows the maintainers the ability to
uphold quality by limiting the degrees of freedom for problems facing the ecosystem.

For implementing business logic, Go's approach is fantastic.
Go is easy to learn, compile times are blazing, and feature deprecation in the language is a non-issue.
There is usually one way to do a thing and you're effectively guaranteed it will do it well.
For packaging, on the other hand, I find this approach a bit limiting.

Fundamentally, packaging is user-facing.
Packaging effects how you solve problems because the problem involves end-user input.
Those considerations could be the difference between a user installing the application or not.
Without installs, you're guaranteed no users.

## How Go's default packaging works

Installing Go packages behaves nearly identical to building locally in development.
The user runs,

```shell
go install github.com/octocat/application@v1.2.3
```

Go then fetches the source code from that repository at that version and builds it locally.
One can't help but appreciate the simplicity.

This is similar to other, modern languages like Rust's `cargo install` however Go goes a step
further and only requires source code to be published (i.e. no [crates.io](https://crates.io/) dependency).
This reduces overhead for maintainers while allowing the ecosystem to be federated.
Pretty solid overall.

### Issues with Go packaging

To be fair, Go packaging is 95% complete and it is really good at what it does do.
I personally have an extremely low pain tolerance for software and an extra 100ms will bother me if
I know it could have been avoided..
Part of the issue is that I intentionally use low-end hardware because UX and accessibility matters
a lot to me.
For most use-cases, Go packaging is perfectly fine and requires minimal maintenance on the end of
the developers.

For me, I am willing to trade a bit of effort for the optimal user experience; I enjoy these things.
Also, this approach is mutually-exclusive with Go's packaging which is still available to users if
desired..

The majority of my complaints are really just, "Go doesn't have a canonical package repository."

1. Installing Go packages requires installing Go
2. Installing Go packages requires building them from source
3. Installing Go packages requires specific versions of Go installed
4. Managing Go packages lacks some reproducability features

## GoReleaser filling in the gaps

If Go's default packaging is 95% complete, [GoReleaser](https://goreleaser.com/) gets it to 99%.
GoReleaser is an absolutely phenomenal tool and I wish I had more time to use it properly.
For most, basic Go applications, deployments are a simple Github Action workflow,

```yaml
  goreleaser:
    runs-on: ubuntu-latest
    environment:
      name: release
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # ratchet:actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
      - uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # ratchet:actions/setup-go@v5
        with:
          go-version: stable
          cache: false
      - uses: goreleaser/goreleaser-action@e435ccd777264be153ace6237001ef4d979d3a7a # ratchet:goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: "~> v2"
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

_Most of the complexity here is for the sake of security and isn't that interesting. It mostly just: 1. checkouts the code 2. installs Go 3. publishes._

This then updates the Github Releases with beautiful, compressed, prebuilt Go binaries for all major platforms.
The building is in parallel, so sub-1 minute deployments are common.

### Issues with GoReleaser

There are only 3 minor issues with GoReleaser,

1. There isn't a ubiquitous, CLI solution for downloading these artifacts from Github.
  a. This does imply  the platform detection is not automatic and therefore error-prone.
2. They're tarballs, so installing requires un-archiving after downloading.

## Solving the last mile problem (of Go packaging)

`uv` solves both of GoReleaser's issues:

- `uv` is now a ubiquitous tool for the most popular programming language.
- [Python wheels](https://realpython.com/python-wheels/#what-is-a-python-wheel) are glorified `.zip` files which `uv` happily un-archives.

Also, `uv` itself is [really freaking fast](https://github.com/astral-sh/uv/blob/main/BENCHMARKS.md#warm-installation).

### Packaging a Go application with Python tools

Packaging with Python tools has 2 major parts:

- `pyproject.toml`: defines the package configurations analogous to the `go.mod` file
- `hatch_build.py`: a custom hook to handle Go building specifics

There are a handful of build backends available.
The common, legacy backend is [setuptools](https://pypi.org/project/setuptools/) while `uv` also now has it's [own backend](https://docs.astral.sh/uv/concepts/build-backend/).
I personally use [hatchling](https://pypi.org/project/hatchling/).
Hatchling is good and has plugins support of which I use to get the app version from source control.

The setup is simple and straight-forward, most of which is setting appropriate metadata,

`pyproject.toml`:

```toml
[build-system]
requires = ["hatchling", "hatch-vcs", "go-bin~=1.24", "manygo"]
build-backend = "hatchling.build"

[project]
name = "nature-sounds"
description = "A nature sounds player for the command-line"
license = {file = "LICENSE"}
authors = [{ name = "Jamison Lahman", email = "jamison@lahman.dev" }]
readme = "README.md"
requires-python = ">=3.6"
keywords = [
  "nature-sounds", "white-noise", "sounds"
]
classifiers = [
    "Programming Language :: Go",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dynamic = ["version"]


[project.urls]
Repository = "https://github.com/jmelahman/nature-sounds"

[tool.hatch.build]
include = ["go.mod", "go.sum", "main.go"]

[tool.hatch.version]
source = "vcs"

[tool.hatch.build.hooks.custom]
binary_name = "nature-sounds"
```

This does invoke a custom hatchling hook at build time which: 1. builds the Go app 2. moves it where it needs to be,

`hatch_build.py`:

```python
from __future__ import annotations

import os
import subprocess

from hatchling.builders.hooks.plugin.interface import BuildHookInterface

import manygo


class GoBinaryBuildHook(BuildHookInterface):
    def initialize(self, version, build_data) -> None:  # noqa: ANN001, ARG002
        build_data["pure_python"] = False
        goos = os.getenv("GOOS")
        goarch = os.getenv("GOARCH")
        if goos and goarch:
            build_data["tag"] = "py3-none-" + manygo.get_platform_tag(goos=goos, goarch=goarch)
        binary_name = self.config["binary_name"]
        tag = os.getenv("GITHUB_REF_NAME", "dev")
        commit = os.getenv("GITHUB_SHA", "none")

        if not os.path.exists(binary_name):
            print(f"Building Go binary '{binary_name}'...")
            subprocess.check_call(  # noqa: S603
                [
                    "go",
                    "build",
                    f"-ldflags=-X main.version={tag} -X main.commit={commit} -s -w",
                    "-o",
                    binary_name,
                ],
            )

        build_data["shared_scripts"] = {binary_name: binary_name}
```

A big positive about this hook is that it's completely application agnostic.
All of my projects share the same hook implementation.

Building is a matter of `uv build --wheel`.
You could build a source distribution (sdist), but it doesn't really make sense
The output is a `.whl` file with the prebuilt Go application inside.

### `manygo` and the power if small, python libraries

Go and Python have similar semantics for platform compatibility.
I wrote a very simple Python library to convert [Go's](https://go.dev/doc/install/source#environment) platform semantics to [Python's](https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/#platform-tag) called [manygo](https://github.com/jmelahman/manygo) (a reference to Python's [manylinux](https://github.com/pypa/manylinux) wheels).

Overall, it's a single `__init__.py` file with 1 function, 100% test coverage, and strong, exported types.

It's easy to think, "this is such a simple, uncommon library it's not worth creating", but it took
about 1 hour in total and now I can safely share it between all of my projects without cumbersome
symlinking or duplication hacks.
It also serves as a template for future pure-python libraries.

I recommend everyone make as many, small, modular libraries as they need.

### Optimizing reproducability and `go-bin`

Initially, the `hatch_build.py` above invoke `go` from the command-line.
This was typically the user's global install.
Moreover, builds would fail if the user did not have Go installed beforehand.
Considering I was packaging with Python tools *because* I suspected users weren't familiar with Go, I needed a way to provide `go` to users using Python machinery.

[github.com/golang/go](https://github.com/golang/go) itself is a Go app, so I can build and publish it to PyPi using the aforementioned setup.
This is precisely what I did with [go-bin](https://github.com/jmelahman/go-bin).
Go maintainers graciously supply prebuilt artifacts anyways, so I just needed to ensure it ran properly from inside a wheel.

Now, all a Go application needs to do to ensure `go` is available at build time is add a `build-system` dependency,

```toml
[build-system]
requires = ["go-bin~=1.24", ...]
```

This, in theory, has potential usages for building [Go-based C-extensions](https://words.filippo.io/building-python-modules-with-go-1-5/) in Python applications.
Given [Go no longer supports multiple, c-shared libraries](https://www.youtube.com/watch?v=xuv9A7CJF54), I've personally abandoned this train of thought, but may one day prove useful.

If nothing else, I think it's neat you can now run `go` directly with `uvx`,

```shell
$ uvx --from=go-bin~=1.24 \
  go version
go version go1.24.5 linux/amd64
```

One issue I did run into is that [PyPi limits individual packages to 100MB and projects to 10GB](https://docs.pypi.org/project-management/storage-limits/).
The Go binary is somewhere around 80MB + each version has about 10 variations for various platform support.
I've had to resort to supporting only a handful of Go versions otherwise after about a handful of versions I will run out of repository space. :/
It makes sense from their perspective and I appreciate their platform regardless.
